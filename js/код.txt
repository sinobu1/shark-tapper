// js/achievementManager.js
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";

class AchievementManager {
  constructor() {
    // Состояние достижений теперь хранится в stateManager
    this.setupEventListeners();
    console.log("AchievementManager initialized");
  }

  checkAchievements(currentState) {
    const achievementsState = currentState.achievements;
    let achievementUnlocked = false;

    for (const id in config.achievements) {
      const achievementConfig = config.achievements[id];
      const achievementState = achievementsState[id];

      if (!achievementState.unlocked) {
        // Используем функцию проверки из конфига
        const currentProgress = achievementConfig.check(currentState);
        // Обновляем прогресс в состоянии (если нужно показывать)
        // stateManager должен позаботиться об обновлении progress через события?
        // Или мы обновляем здесь и потом шлем событие?
        // Пока просто проверяем порог
        if (currentProgress >= achievementConfig.threshold) {
          achievementsState[id].unlocked = true; // Модифицируем копию для события
          achievementUnlocked = true;
          console.log(`Achievement unlocked: ${achievementConfig.name}`);
          // Выдаем награду
          if (achievementConfig.rewardGems > 0) {
            eventBus.emit("currency:add", {
              type: "gem",
              amount: achievementConfig.rewardGems,
            });
          }
          // Показываем уведомление
          eventBus.emit("ui:show_achievement", achievementConfig); // Используем achievementConfig для данных
        }
        // Можно обновлять поле progress, если оно есть в state.achievements[id]
        // achievementsState[id].progress = currentProgress;
      }
    }
    // Если что-то разблокировалось, нужно обновить состояние в stateManager
    // Лучше, чтобы StateManager сам слушал события (totalTaps, totalCoins и т.д.) и обновлял прогресс ачивок
    // Тогда этот менеджер только показывает уведомление при разблокировке
    /*
         if (achievementUnlocked) {
             // Отправить событие для StateManager, чтобы он обновил achievements в своем состоянии
             eventBus.emit('achievements:update_state', achievementsState);
         }
         */
  }

  setupEventListeners() {
    // Слушаем общее обновление состояния и проверяем все ачивки
    // Это менее оптимально, чем слушать конкретные события (tap, currency:add)
    // но проще для начала
    eventBus.on("state:forAchievements", (state) =>
      this.checkAchievements(state)
    );

    // Альтернатива: Подписка на конкретные события, если stateManager их генерирует
    // eventBus.on('stats:updated', ({ key, value }) => { /* ... */ });
  }
}

// Экспортируем единственный экземпляр
export const achievementManager = new AchievementManager();

// js/config.js
export const config = {
  firebase: {
    apiKey: "AIzaSyDgi8vq_3Wpky7o_bzWbVuKRtOShGjd5o4",
    authDomain: "tralalero-fec07.firebaseapp.com",
    databaseURL: "https://tralalero-fec07-default-rtdb.firebaseio.com",
    projectId: "tralalero-fec07",
    storageBucket: "tralalero-fec07.firebasestorage.app",
    messagingSenderId: "322571108862",
    appId: "1:322571108862:web:14f4fe3a8168abab19c0af",
  },
  game: {
    baseTapValue: 1,
    criticalChance: 0.05,
    criticalMultiplier: 2,
    oreChance: 0.03, // Базовый шанс руды
    gemChanceOnTap: 0.01, // Шанс гема при тапе
    energyRegenRate: 1, // Базовая регенерация
    energyCostPerTap: 1,
    maxEnergy: 100, // Базовая макс. энергия
    boostMultiplier: 2, // Множитель для буста
    boostDuration: 10000, // Длительность буста (мс)
    boostCostGems: 1, // Стоимость буста в гемах
    levelUpBaseTapIncreaseInterval: 5, // Каждые N уровней +1 к базовому тапу
    levelUpBaseTapIncreaseAmount: 1, // На сколько увеличивать базовый тап
    baseProgressToNextLevel: 100, // Опыт для первого уровня
    progressToNextLevelMultiplier: 1.5, // Множитель опыта для след. уровня
    saveInterval: 30000, // Интервал автосохранения (мс)
    duplicateSkinCoinMultiplier: 0.2, // % от стоимости скина в монетах за дубликат
    minCoinsForDuplicateSkin: 1000, // Мин. монет за дубликат
    fallbackLootboxCoins: 500, // Монет, если из лутбокса ничего не выпало
  },
  // Определения предметов магазина (статичные данные)
  helpers: {
    dolphin: {
      name: "Дельфин",
      cost: 500,
      income: 20,
      currency: "coin",
      costIncrease: 1.15,
      rarity: "common",
      icon: "fa-fish",
    },
    orca: {
      name: "Косатка",
      cost: 1500,
      income: 50,
      currency: "coin",
      costIncrease: 1.2,
      rarity: "rare",
      icon: "fa-fish",
    }, // Иконки можно кастомизировать
    whale: {
      name: "Кит",
      cost: 5000,
      income: 100,
      currency: "coin",
      costIncrease: 1.25,
      rarity: "rare",
      icon: "fa-fish",
    },
    shark: {
      name: "Акула",
      cost: 15000,
      income: 200,
      currency: "coin",
      costIncrease: 1.3,
      rarity: "epic",
      icon: "fa-fish",
    },
    submarine: {
      name: "Подлодка",
      cost: 50000,
      income: 500,
      currency: "coin",
      costIncrease: 1.35,
      rarity: "epic",
      icon: "fa-ship",
    },
    fleet: {
      name: "Флот",
      cost: 150000,
      income: 1000,
      currency: "coin",
      costIncrease: 1.4,
      rarity: "legendary",
      icon: "fa-anchor",
    },
  },
  upgrades: {
    powerTap: {
      name: "NFT Сила удара",
      cost: 2000,
      effect: 1,
      currency: "coin",
      maxLevel: 10,
      rarity: "common",
      costIncrease: 1.5,
      icon: "fa-fist-raised",
      description: (lvl, effect) => `+${lvl * effect} к базовому урону`,
    },
    criticalChance: {
      name: "Критический шанс",
      cost: 5000,
      effect: 0.01,
      currency: "coin",
      maxLevel: 5,
      rarity: "rare",
      costIncrease: 2,
      icon: "fa-bolt",
      description: (lvl, effect) =>
        `+${(lvl * effect * 100).toFixed(1)}% к шансу крита`,
    },
    oreChance: {
      name: "Удача рудокопа",
      cost: 3000,
      effect: 0.005,
      currency: "coin",
      maxLevel: 10,
      rarity: "rare",
      costIncrease: 1.8,
      icon: "fa-gem",
      description: (lvl, effect) =>
        `+${(lvl * effect * 100).toFixed(1)}% к шансу руды`,
    },
    energyRegen: {
      name: "Регенерация",
      cost: 10,
      effect: 1,
      currency: "gem",
      maxLevel: 5,
      rarity: "epic",
      costIncrease: 2.5,
      icon: "fa-battery-three-quarters",
      description: (lvl, effect) => `+${lvl * effect} к регенерации энергии`,
    },
    energyMax: {
      name: "Энергия+",
      cost: 5,
      effect: 50,
      currency: "gem",
      maxLevel: 10,
      rarity: "epic",
      costIncrease: 1.5,
      icon: "fa-battery-full",
      description: (lvl, effect) => `+${lvl * effect} к максимуму энергии`,
    },
    incomeMultiplier: {
      name: "Множитель дохода",
      cost: 10000,
      effect: 1.2,
      currency: "coin",
      maxLevel: 5,
      rarity: "legendary",
      costIncrease: 3,
      icon: "fa-chart-line",
      description: (lvl, effect) =>
        `x${Math.pow(effect, lvl).toFixed(2)} к доходу помощников`,
    },
  },
  skins: {
    basic: {
      name: "Базовая акула",
      cost: 0,
      costGems: 0,
      costOre: 0,
      multiplier: 1,
      rarity: "common",
      iconSrc:
        "https://raw.githubusercontent.com/sinobu1/shark-tapper/main/shark.png",
      description: "Стандартный NFT скин",
    },
    gold: {
      name: "Золотая акула",
      cost: 5000,
      costGems: 5,
      costOre: 0,
      multiplier: 1.5,
      rarity: "rare",
      iconSrc:
        "https://raw.githubusercontent.com/sinobu1/shark-tapper/main/shark.png",
      description: (mult) => `x${mult} к силе тапа`,
    }, // TODO: Add specific icon paths
    robot: {
      name: "Акула-робот",
      cost: 10000,
      costGems: 0,
      costOre: 10,
      multiplier: 2,
      rarity: "rare",
      iconSrc:
        "https://raw.githubusercontent.com/sinobu1/shark-tapper/main/shark.png",
      description: (mult) => `x${mult} к силе тапа`,
    },
    dragon: {
      name: "Акула-дракон",
      cost: 20000,
      costGems: 10,
      costOre: 0,
      multiplier: 3,
      rarity: "epic",
      iconSrc:
        "https://raw.githubusercontent.com/sinobu1/shark-tapper/main/shark.png",
      description: (mult) => `x${mult} к силе тапа`,
    },
    cyber: {
      name: "Кибер-акула",
      cost: 50000,
      costGems: 0,
      costOre: 20,
      multiplier: 5,
      rarity: "epic",
      iconSrc:
        "https://raw.githubusercontent.com/sinobu1/shark-tapper/main/shark.png",
      description: (mult) => `x${mult} к силе тапа`,
    },
    legendary: {
      name: "Легендарная акула",
      cost: 100000,
      costGems: 0,
      costOre: 0,
      multiplier: 10,
      rarity: "legendary",
      iconSrc:
        "https://raw.githubusercontent.com/sinobu1/shark-tapper/main/shark.png",
      description: (mult) => `x${mult} к силе тапа`,
    },
  },
  lootboxes: {
    common: {
      name: "Обычный лутбокс",
      cost: 5000,
      currency: "coin",
      icon: "fa-box-open",
      rarity: "common",
      description: "Шанс получить обычные и редкие предметы",
      rewards: [
        { type: "coin", min: 1000, max: 5000, chance: 0.6 },
        { type: "gem", min: 1, max: 3, chance: 0.3 },
        { type: "helper", rarity: "common", chance: 0.1 },
      ],
    },
    rare: {
      name: "Редкий лутбокс",
      cost: 15000,
      currency: "coin",
      icon: "fa-box-open",
      rarity: "rare",
      description: "Шанс получить редкие и эпические предметы",
      rewards: [
        { type: "coin", min: 5000, max: 15000, chance: 0.5 },
        { type: "gem", min: 3, max: 5, chance: 0.3 },
        { type: "helper", rarity: "rare", chance: 0.15 },
        { type: "skin", rarity: "rare", chance: 0.05 },
      ],
    },
    epic: {
      name: "Эпический лутбокс",
      cost: 50000,
      currency: "coin",
      icon: "fa-box-open",
      rarity: "epic",
      description: "Шанс получить эпические и легендарные предметы",
      rewards: [
        { type: "coin", min: 15000, max: 50000, chance: 0.4 },
        { type: "gem", min: 5, max: 10, chance: 0.3 },
        { type: "helper", rarity: "epic", chance: 0.2 },
        { type: "skin", rarity: "epic", chance: 0.1 },
      ],
    },
    legendary: {
      name: "Легендарный лутбокс",
      cost: 150000,
      currency: "coin",
      icon: "fa-box-open",
      rarity: "legendary",
      description: "Высокий шанс на лучшие предметы",
      rewards: [
        { type: "coin", min: 50000, max: 150000, chance: 0.3 },
        { type: "gem", min: 10, max: 20, chance: 0.2 },
        { type: "helper", rarity: "legendary", chance: 0.3 },
        { type: "skin", rarity: "legendary", chance: 0.2 },
      ],
    },
  },
  achievements: {
    // Перемещаем сюда для централизации
    firstTap: {
      name: "Первые шаги",
      description: "Сделайте 100 тапов",
      threshold: 100,
      rewardGems: 5,
      check: (state) => state.totalTaps,
    },
    richTapper: {
      name: "Богатый тапер",
      description: "Заработайте 10,000 монет",
      threshold: 10000,
      rewardGems: 5,
      check: (state) => state.totalCoins,
    },
    sharkMaster: {
      name: "Мастер акул",
      description: "Достигните 10 уровня",
      threshold: 10,
      rewardGems: 5,
      check: (state) => state.playerLevel,
    },
    criticalHit: {
      name: "Критический удар",
      description: "Сделайте 10 критических ударов",
      threshold: 10,
      rewardGems: 5,
      trackEvent: "stats:criticalHits",
      check: (state) => state.stats.criticalHits,
    }, // Добавим отслеживание
    energyMaster: {
      name: "Энергичный",
      description: "Используйте 1000 энергии",
      threshold: 1000,
      rewardGems: 5,
      trackEvent: "stats:energySpent",
      check: (state) => state.stats.energySpent,
    }, // Добавим отслеживание
  },
};

// js/effectManager.js
import { eventBus } from "./eventBus.js";

class EffectManager {
  constructor() {
    this.particlesContainer = document.getElementById("particles");
    this.sharkWrapper = document.querySelector(".shark-wrapper");
    if (!this.particlesContainer)
      console.warn("Particles container not found.");
    if (!this.sharkWrapper) console.warn("Shark wrapper not found.");

    this.createParticles();
    this.setupEventListeners();
    console.log("EffectManager initialized");
  }

  createParticles() {
    if (!this.particlesContainer) return;
    this.particlesContainer.innerHTML = ""; // Очищаем старые частицы
    const particleCount = Math.min(100, Math.floor(window.innerWidth / 15));
    const fragment = document.createDocumentFragment();

    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement("div");
      particle.classList.add("particle");
      const size = Math.random() * 2 + 1;
      particle.style.width = `${size}px`;
      particle.style.height = `${size}px`;
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.top = `${Math.random() * window.innerHeight}px`;
      particle.style.opacity = Math.random() * 0.5 + 0.1;
      const duration = Math.random() * 20 + 10;
      const delay = Math.random() * -duration;
      particle.style.animation = `float ${duration}s linear ${delay}s infinite`;
      fragment.appendChild(particle);
    }
    this.particlesContainer.appendChild(fragment);
    // Убедись, что CSS для .particle и @keyframes float определен в style.css
  }

  showTapEffect({ type, event, text }) {
    if (!event || !this.sharkWrapper) return;
    const wrapperRect = this.sharkWrapper.getBoundingClientRect();
    const x = event.clientX - wrapperRect.left;
    const y = event.clientY - wrapperRect.top;

    const effectContainer = document.createElement("div");
    effectContainer.className = "tap-effect-container";
    effectContainer.style.left = `${x}px`;
    effectContainer.style.top = `${y}px`;

    const textElement = document.createElement("div");
    let textClass = "tap-plus";
    let animationDuration = 800; // ms

    switch (type) {
      case "gem":
        textClass = "tap-gem";
        break;
      case "ore":
        textClass = "tap-ore";
        break;
      case "energy":
        textClass = "tap-energy";
        break; // Если нужно
      case "critical":
        textClass = "critical-hit";
        animationDuration = 1000; // Дольше для крита
        break;
      case "coin": // По умолчанию
      default:
        textClass = "tap-plus";
        break;
    }
    textElement.className = `tap-text ${textClass}`;
    textElement.innerText = text;
    effectContainer.appendChild(textElement);

    this.sharkWrapper.appendChild(effectContainer);

    setTimeout(() => {
      effectContainer.remove();
    }, animationDuration);
  }

  activateBoostEffect({ duration }) {
    if (!this.sharkWrapper) return;
    const boostEffect = document.createElement("div");
    boostEffect.className = "boost-effect-overlay"; // Стили должны быть в CSS
    this.sharkWrapper.appendChild(boostEffect);

    setTimeout(() => {
      boostEffect.remove();
    }, duration);
  }

  setupEventListeners() {
    eventBus.on("effect:show_tap", (data) => this.showTapEffect(data));
    eventBus.on("effect:show_boost", (data) => this.activateBoostEffect(data));
    // Возможно, ресайз окна для пересоздания частиц
    window.addEventListener("resize", () => this.createParticles());
  }
}

// Экспортируем единственный экземпляр
export const effectManager = new EffectManager();

// js/eventBus.js
class EventBus {
  constructor() {
    this.listeners = {};
    console.log("EventBus initialized");
  }

  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  off(event, callback) {
    if (!this.listeners[event]) return;
    const index = this.listeners[event].indexOf(callback);
    if (index !== -1) {
      this.listeners[event].splice(index, 1);
    }
  }

  emit(event, data = {}) {
    // console.debug(`Event emitted: ${event}`, data); // Для отладки
    if (!this.listeners[event]) return;
    this.listeners[event].forEach((callback) => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in event listener for ${event}:`, error);
      }
    });
  }

  // Синхронный вызов для получения данных (используется осторожно!)
  emitSync(event, data = {}) {
    if (!this.listeners[event]) return null;
    // Предполагаем, что только один слушатель вернет результат
    for (const callback of this.listeners[event]) {
      try {
        const result = callback(data);
        if (result !== undefined) {
          return result;
        }
      } catch (error) {
        console.error(`Error in sync event listener for ${event}:`, error);
        return null;
      }
    }
    return null;
  }
}

// Экспортируем единственный экземпляр
export const eventBus = new EventBus();

// js/gameCore.js
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";
import { formatNumber } from "./utils.js"; // Утилита для форматирования

class GameCore {
  constructor() {
    this.passiveIncomeInterval = null;
    this.energyRegenInterval = null;
    this.boostCheckInterval = null; // Для проверки окончания буста
    this.setupEventHandlers();
    this.startGameLoops();
    this.initTelegramUser();
    console.log("GameCore initialized");
  }

  initTelegramUser() {
    try {
      if (window.Telegram && window.Telegram.WebApp) {
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        const user = tg.initDataUnsafe?.user;
        if (user) {
          console.log("Telegram user data:", user);
          eventBus.emit("user:info_updated", {
            name: user.first_name || user.username || "Игрок",
            photoUrl: user.photo_url || null,
          });
        } else {
          console.warn("Telegram user data not available.");
          eventBus.emit("user:info_updated", { name: "Гость", photoUrl: null });
        }
      } else {
        console.warn("Telegram WebApp API not found.");
        eventBus.emit("user:info_updated", { name: "Гость", photoUrl: null });
      }
    } catch (e) {
      console.error("Error initializing Telegram User:", e);
      eventBus.emit("user:info_updated", { name: "Гость", photoUrl: null });
    }
  }

  handleTap(event) {
    const state = eventBus.emitSync("state:get");
    if (!state) return;

    // Проверка энергии
    if (state.energy.current < config.game.energyCostPerTap) {
      eventBus.emit("ui:notification_show", {
        type: "error",
        message: "Недостаточно энергии!",
      });
      this.triggerHapticFeedback("error");
      return;
    }

    // Снимаем энергию
    eventBus.emit("energy:remove", { amount: config.game.energyCostPerTap });

    // Определяем силу тапа
    let tapValue = state.derived.currentTapValue; // Уже включает апгрейды и скин
    let isCritical = Math.random() < state.derived.criticalChance;

    if (isCritical) {
      tapValue = Math.floor(tapValue * config.game.criticalMultiplier);
    }
    if (state.boost.active) {
      tapValue = Math.floor(tapValue * config.game.boostMultiplier);
    }

    // Добавляем монеты
    eventBus.emit("currency:add", { type: "coin", amount: tapValue });

    // Показываем основной эффект (+монеты или крит)
    if (isCritical) {
      eventBus.emit("effect:show_tap", {
        type: "critical",
        event,
        text: "КРИТ!",
      });
      // Можно добавить и показ монет под критом, если нужно
      eventBus.emit("effect:show_tap", {
        type: "coin",
        event,
        text: `+${formatNumber(tapValue)}`,
      });
    } else {
      eventBus.emit("effect:show_tap", {
        type: "coin",
        event,
        text: `+${formatNumber(tapValue)}`,
      });
    }

    // Шанс на гем и руду
    const dropRandom = Math.random();
    let droppedItem = false; // Флаг, чтобы не показывать монеты, если выпало другое

    if (dropRandom < config.game.gemChanceOnTap) {
      // Шанс гема
      eventBus.emit("currency:add", { type: "gem", amount: 1 });
      eventBus.emit("effect:show_tap", { type: "gem", event, text: "+1 Гем" });
      droppedItem = true;
    } else if (dropRandom < state.derived.oreChance) {
      // Шанс руды (уже включает апгрейды)
      eventBus.emit("currency:add", { type: "ore", amount: 1 });
      eventBus.emit("effect:show_tap", { type: "ore", event, text: "+1 Руда" });
      droppedItem = true;
    }

    // Обновляем статистику тапов и прочее (StateManager сделает это)
    eventBus.emit("game:tap_processed", { tapValue, isCritical });

    // Прогресс уровня
    this.checkLevelUp(state);

    // Вибрация
    this.triggerHapticFeedback("light");
  }

  // Замени существующий checkLevelUp этим:
  handleTapProcessed({ tapValue, isCritical }) {
    const state = eventBus.emitSync("state:get");
    if (!state) return;

    const currentLevel = state.player.level;
    const currentProgress = state.player.progress;
    const neededProgress = state.player.progressToNextLevel;
    const newProgressRaw = currentProgress + 1; // +1 за тап

    if (newProgressRaw >= neededProgress) {
      // --- Level Up ---
      const newLevel = currentLevel + 1;
      const newProgress = newProgressRaw - neededProgress; // Остаток опыта
      const newProgressToNextLevel = Math.max(
        config.game.baseProgressToNextLevel,
        Math.floor(neededProgress * config.game.progressToNextLevelMultiplier)
      );

      // Отправляем событие о левелапе
      eventBus.emit("game:level_up", {
        newLevel,
        newProgress,
        newProgressToNextLevel,
      });
      // UI покажет уведомление
      eventBus.emit("ui:show_level_up", { newLevel });
      // Вибрация при левелапе
      this.triggerHapticFeedback("medium");
    } else {
      // --- Просто прогресс ---
      // Отправляем событие для StateManager, чтобы он обновил только progress
      eventBus.emit("game:progress_update", { newProgress: newProgressRaw });
    }

    // Обновляем статистику (кол-во тапов, криты) - это событие уже есть
    eventBus.emit("game:tap_stats_update", { isCritical });
  }

  setupEventHandlers() {
    // Запросы от UI
    eventBus.on("game:tap_request", ({ event }) => this.handleTap(event));
    eventBus.on("game:boost_request", () => this.activateBoost());

    // НОВЫЙ ОБРАБОТЧИК для обновления статистики и прогресса после всех расчетов тапа
    eventBus.on("game:tap_processed", (data) => this.handleTapProcessed(data));
  }

  activateBoost() {
    const state = eventBus.emitSync("state:get");
    if (!state || state.boost.active) return; // Нельзя активировать, если уже активен

    const cost = config.game.boostCostGems;
    // Проверяем и списываем гемы
    const success = eventBus.emitSync("currency:remove", {
      type: "gem",
      amount: cost,
    });

    if (success) {
      // Уведомляем StateManager
      eventBus.emit("game:boost_activated");
      // Показываем эффект
      eventBus.emit("effect:show_boost", {
        duration: config.game.boostDuration,
      });
      // Уведомление
      eventBus.emit("ui:notification_show", {
        type: "success",
        message: "Буст активирован!",
      });
      this.triggerHapticFeedback("medium");
    } else {
      eventBus.emit("ui:notification_show", {
        type: "error",
        message: "Недостаточно гемов!",
      });
    }
  }

  // Проверка и деактивация буста
  checkBoostEnd() {
    const state = eventBus.emitSync("state:get");
    if (state && state.boost.active && Date.now() >= state.boost.endTime) {
      eventBus.emit("game:boost_deactivated");
      console.log("Boost deactivated");
    }
  }

  startGameLoops() {
    // Пассивный доход
    this.passiveIncomeInterval = setInterval(() => {
      const state = eventBus.emitSync("state:get");
      if (state && state.derived.passiveIncomePerSec > 0) {
        eventBus.emit("currency:add", {
          type: "coin",
          amount: state.derived.passiveIncomePerSec,
        });
      }
    }, 1000);

    // Регенерация энергии
    this.energyRegenInterval = setInterval(() => {
      const state = eventBus.emitSync("state:get");
      if (state && state.energy.current < state.energy.max) {
        eventBus.emit("energy:add", { amount: state.energy.regenRate });
      }
    }, 1000);

    // Проверка окончания буста
    this.boostCheckInterval = setInterval(() => this.checkBoostEnd(), 1000);
  }

  stopGameLoops() {
    clearInterval(this.passiveIncomeInterval);
    clearInterval(this.energyRegenInterval);
    clearInterval(this.boostCheckInterval);
  }

  triggerHapticFeedback(style = "light") {
    try {
      if (window.Telegram?.WebApp?.HapticFeedback?.impactOccurred) {
        window.Telegram.WebApp.HapticFeedback.impactOccurred(style); // 'light', 'medium', 'heavy', 'rigid', 'soft'
      } else if (
        window.Telegram?.WebApp?.HapticFeedback?.notificationOccurred &&
        (style === "success" || style === "warning" || style === "error")
      ) {
        window.Telegram.WebApp.HapticFeedback.notificationOccurred(style);
      }
    } catch (e) {
      // console.warn("Haptic feedback failed:", e);
    }
  }

  setupEventHandlers() {
    // Запросы от UI
    eventBus.on("game:tap_request", ({ event }) => this.handleTap(event));
    eventBus.on("game:boost_request", () => this.activateBoost());

    // Запросы от Магазина (перенаправляем в ShopManager)
    eventBus.on("shop:buy_helper_request", ({ helperId }) => {
      import("./shopManager.js").then((module) =>
        module.shopManager.buyHelper(helperId)
      );
    });
    eventBus.on("shop:buy_upgrade_request", ({ upgradeId }) => {
      import("./shopManager.js").then((module) =>
        module.shopManager.buyUpgrade(upgradeId)
      );
    });
    eventBus.on("shop:handle_skin_request", ({ skinId }) => {
      import("./shopManager.js").then((module) =>
        module.shopManager.handleSkin(skinId)
      );
    });
    eventBus.on("shop:open_lootbox_request", ({ lootboxType }) => {
      import("./shopManager.js").then((module) =>
        module.shopManager.openLootbox(lootboxType)
      );
    });
  }
}

// Экспортируем единственный экземпляр
export const gameCore = new GameCore();

// js/main.js

// Импортируем основные модули (их конструкторы выполнятся при импорте)
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";
import { stateManager } from "./stateManager.js"; // Инициализирует StateManager
import { uiManager } from "./uiManager.js"; // Инициализирует UIManager и кэширует элементы
import { effectManager } from "./effectManager.js"; // Инициализирует эффекты
import { achievementManager } from "./achievementManager.js"; // Инициализирует ачивки
import { gameCore } from "./gameCore.js"; // Инициализирует ядро игры и циклы
import { saveManager } from "./saveManager.js"; // Инициализирует систему сохранений

document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM fully loaded and parsed. Initializing application.");

  // К этому моменту все модули уже должны быть инициализированы через импорты.
  // Важно: StateManager, UIManager, EffectManager должны быть инициализированы до GameCore и SaveManager.

  // Запускаем загрузку игры
  saveManager.loadGame(); // SaveManager запросит состояние у StateManager или начнет новую игру

  console.log("Application initialization complete. Game should be running.");

  // Отладка: доступ к модулям через консоль (НЕ ДЛЯ ПРОДА!)
  window.dev = {
    eventBus,
    config,
    stateManager,
    uiManager,
    effectManager,
    achievementManager,
    gameCore,
    saveManager,
    getState: () => stateManager.getState(),
    addCoins: (amount) =>
      eventBus.emit("currency:add", {
        type: "coin",
        amount: parseInt(amount) || 1000,
      }),
    addGems: (amount) =>
      eventBus.emit("currency:add", {
        type: "gem",
        amount: parseInt(amount) || 10,
      }),
    save: () => saveManager.saveGame(true),
    load: () => saveManager.loadGame(),
    reset: () => {
      localStorage.removeItem(`gameState_${saveManager.userId}`);
      window.location.reload();
    },
  };
});

// НЕ ИСПОЛЬЗУЙТЕ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ИЛИ AppShop/gameCoreInstance КАК РАНЬШЕ!
// Взаимодействие с HTML теперь идет через обработчики событий в UIManager.

// js/saveManager.js
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";

class SaveManager {
  constructor() {
    this.userId = this.getUserId();
    this.database = null;
    this.saveTimer = null;
    this.isSaving = false;
    this.debounceTimer = null; // Для отложенного сохранения
    this.saveInterval = config.game.saveInterval || 30000;

    this.initializeFirebase();
    this.setupEventListeners();
    console.log(`SaveManager initialized for user: ${this.userId}`);
  }

  getUserId() {
    // Пытаемся получить ID из Telegram
    try {
      const tgUser = window.Telegram?.WebApp?.initDataUnsafe?.user;
      if (tgUser?.id) {
        return `tg_${tgUser.id}`;
      }
    } catch (e) {
      console.warn("Could not get Telegram User ID", e);
    }
    // Возвращаем гостевой ID или ID из localStorage
    let guestId = localStorage.getItem("guestUserId");
    if (!guestId) {
      guestId = `guest_${Date.now()}_${Math.random()
        .toString(36)
        .substring(2, 9)}`;
      localStorage.setItem("guestUserId", guestId);
    }
    return guestId;
  }

  initializeFirebase() {
    if (!config.firebase || !window.firebase) {
      console.warn(
        "Firebase config or library not found. Saving to localStorage only."
      );
      return;
    }
    try {
      if (!firebase.apps.length) {
        firebase.initializeApp(config.firebase);
        this.database = firebase.database();
        console.log("Firebase initialized by SaveManager.");
      } else {
        this.database = firebase.database(); // Используем уже инициализированное
        console.log("Firebase already initialized.");
      }
    } catch (error) {
      console.error("Firebase initialization failed:", error);
      this.database = null;
    }
  }

  // Запускает процесс загрузки
  loadGame() {
    console.log("Attempting to load game...");
    if (this.database) {
      this.loadFromFirebase();
    } else {
      this.loadFromLocalStorage();
    }
  }

  loadFromFirebase() {
    this.database
      .ref("users/" + this.userId)
      .once("value")
      .then((snapshot) => {
        const savedState = snapshot.val();
        if (savedState) {
          console.log("Game loaded from Firebase.");
          eventBus.emit("state:load", savedState); // Отправляем данные в StateManager
        } else {
          console.log("No saved game in Firebase. Trying LocalStorage.");
          this.loadFromLocalStorage();
        }
      })
      .catch((error) => {
        console.error("Error loading from Firebase:", error);
        this.loadFromLocalStorage(); // Fallback
      });
  }

  loadFromLocalStorage() {
    try {
      const savedStateString = localStorage.getItem(`gameState_${this.userId}`);
      if (savedStateString) {
        const savedState = JSON.parse(savedStateString);
        console.log("Game loaded from LocalStorage.");
        eventBus.emit("state:load", savedState);
      } else {
        console.log("No saved game in LocalStorage. Starting new game.");
        eventBus.emit("game:new"); // Сигнал для StateManager использовать initial state
      }
    } catch (error) {
      console.error("Error loading from LocalStorage:", error);
      eventBus.emit("ui:notification_show", {
        type: "error",
        message: "Ошибка загрузки сохранения!",
      });
      eventBus.emit("game:new"); // Начинаем новую игру при ошибке
    }
  }

  // Запускает процесс сохранения (с debounce)
  triggerSave() {
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      this.saveGame();
    }, 500); // Небольшая задержка перед сохранением
  }

  saveGame(forceSave = false) {
    if (this.isSaving && !forceSave) {
      // console.log("Save already in progress. Skipping.");
      return;
    }
    this.isSaving = true;

    // Получаем актуальное состояние от StateManager
    const stateToSave = eventBus.emitSync("state:get");

    if (!stateToSave) {
      console.error("Failed to get state for saving.");
      this.isSaving = false;
      return;
    }

    // Удаляем ненужные для сохранения поля (если они вдруг там есть)
    // const cleanState = { ...stateToSave };
    // delete cleanState.derived; // Производные значения не сохраняем
    // Оставляем derived, т.к. StateManager все равно их пересчитает при загрузке

    console.log("Attempting to save game...");

    // Сохраняем локально всегда (как бэкап)
    this.saveToLocalStorage(stateToSave);

    // Сохраняем в Firebase, если доступен
    if (this.database) {
      this.saveToFirebase(stateToSave);
    } else {
      this.isSaving = false; // Если Firebase нет, завершаем процесс сохранения
    }
  }

  saveToFirebase(state) {
    this.database
      .ref("users/" + this.userId)
      .set(state)
      .then(() => {
        console.log("Game saved successfully to Firebase.");
        eventBus.emit("game:saved");
      })
      .catch((error) => {
        console.error("Error saving game to Firebase:", error);
        eventBus.emit("ui:notification_show", {
          type: "error",
          message: "Ошибка онлайн сохранения!",
        });
      })
      .finally(() => {
        this.isSaving = false;
      });
  }

  saveToLocalStorage(state) {
    try {
      localStorage.setItem(`gameState_${this.userId}`, JSON.stringify(state));
      // console.log('Game saved to LocalStorage backup.');
    } catch (error) {
      console.error("Error saving game to LocalStorage:", error);
      // Не спамим пользователя ошибками локального сохранения, если есть Firebase
      if (!this.database) {
        eventBus.emit("ui:notification_show", {
          type: "error",
          message: "Ошибка сохранения игры!",
        });
      }
    }
  }

  setupEventListeners() {
    // Автосохранение по таймеру
    this.saveTimer = setInterval(() => this.triggerSave(), this.saveInterval);

    // Сохранение при закрытии/сворачивании
    window.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        console.log("Page hidden, forcing immediate save.");
        this.saveGame(true); // Принудительное немедленное сохранение
      }
    });

    // Слушаем событие обновления состояния, чтобы инициировать сохранение
    eventBus.on("state:updated", () => this.triggerSave());

    // Очистка таймера (на всякий случай)
    window.addEventListener("unload", () => {
      if (this.saveTimer) clearInterval(this.saveTimer);
      // Можно попытаться сохранить синхронно, но это ненадежно
      // this.saveGame(true);
    });
  }
}

// Экспортируем единственный экземпляр
export const saveManager = new SaveManager();

// js/shopManager.js
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";
import { getCurrentCost, formatLootboxReward } from "./utils.js"; // Импортируем утилиты

class ShopManager {
  constructor() {
    console.log("ShopManager initialized");
  }

  // --- Покупка Помощников ---
  buyHelper(helperId) {
    const helperConfig = config.helpers[helperId];
    if (!helperConfig) return;

    const state = eventBus.emitSync("state:get"); // Запрашиваем текущее состояние
    if (!state) return;

    const helperState = state.shop.helpers[helperId];
    const currentCost = getCurrentCost(
      helperConfig.cost,
      helperState.owned,
      helperConfig.costIncrease
    );
    const currency = helperConfig.currency; // 'coin'

    // Проверяем и списываем валюту через StateManager
    const success = eventBus.emitSync("currency:remove", {
      type: currency,
      amount: currentCost,
    });

    if (success) {
      // Уведомляем StateManager об успешной покупке
      eventBus.emit("shop:item_purchased", {
        itemType: "helper",
        id: helperId,
      });
      eventBus.emit("ui:notification_show", {
        type: "success",
        message: `${helperConfig.name} куплен!`,
      });
    } else {
      eventBus.emit("ui:notification_show", {
        type: "error",
        message: "Недостаточно монет!",
      });
    }
  }

  // --- Покупка Улучшений ---
  buyUpgrade(upgradeId) {
    const upgradeConfig = config.upgrades[upgradeId];
    if (!upgradeConfig) return;

    const state = eventBus.emitSync("state:get");
    if (!state) return;

    const upgradeState = state.shop.upgrades[upgradeId];

    // Проверка максимального уровня
    if (
      upgradeConfig.maxLevel &&
      upgradeState.owned >= upgradeConfig.maxLevel
    ) {
      eventBus.emit("ui:notification_show", {
        type: "info",
        message: "Максимальный уровень!",
      });
      return;
    }

    const currentCost = getCurrentCost(
      upgradeConfig.cost,
      upgradeState.owned,
      upgradeConfig.costIncrease
    );
    const currency = upgradeConfig.currency; // 'coin', 'gem', 'ore'

    const success = eventBus.emitSync("currency:remove", {
      type: currency,
      amount: currentCost,
    });

    if (success) {
      eventBus.emit("shop:item_purchased", {
        itemType: "upgrade",
        id: upgradeId,
      });
      // Уведомление можно не показывать или сделать менее навязчивым
      // eventBus.emit('ui:notification_show', { type: 'success', message: `${upgradeConfig.name} улучшен!` });
    } else {
      let currencyName = currency;
      if (currency === "coin") currencyName = "монет";
      if (currency === "gem") currencyName = "гемов";
      if (currency === "ore") currencyName = "руды";
      eventBus.emit("ui:notification_show", {
        type: "error",
        message: `Недостаточно ${currencyName}!`,
      });
    }
  }

  // --- Покупка / Экипировка Скинов ---
  handleSkin(skinId) {
    const skinConfig = config.skins[skinId];
    if (!skinConfig) return;

    const state = eventBus.emitSync("state:get");
    if (!state) return;

    const skinState = state.shop.skins.owned[skinId];

    if (skinState) {
      // Если скин уже есть - экипируем
      if (state.shop.skins.current !== skinId) {
        eventBus.emit("shop:skin_equip", { skinId });
        eventBus.emit("ui:notification_show", {
          type: "success",
          message: `Скин "${skinConfig.name}" надет!`,
        });
      }
    } else {
      // Покупаем скин
      let canAfford = true;
      let missingCurrency = "";
      const costs = [
        { type: "coin", amount: skinConfig.cost },
        { type: "gem", amount: skinConfig.costGems },
        { type: "ore", amount: skinConfig.costOre },
      ];

      // Проверяем все валюты
      for (const costInfo of costs) {
        if (
          costInfo.amount > 0 &&
          state.currencies[costInfo.type] < costInfo.amount
        ) {
          canAfford = false;
          if (costInfo.type === "coin") missingCurrency = "монет";
          else if (costInfo.type === "gem") missingCurrency = "гемов";
          else if (costInfo.type === "ore") missingCurrency = "руды";
          break;
        }
      }

      if (!canAfford) {
        eventBus.emit("ui:notification_show", {
          type: "error",
          message: `Недостаточно ${missingCurrency}!`,
        });
        return;
      }

      // Списываем все валюты
      let allRemoved = true;
      for (const costInfo of costs) {
        if (costInfo.amount > 0) {
          const removed = eventBus.emitSync("currency:remove", {
            type: costInfo.type,
            amount: costInfo.amount,
          });
          if (!removed) {
            allRemoved = false;
            console.error(
              `Failed to remove ${costInfo.amount} ${costInfo.type} for skin ${skinId}, though check passed!`
            );
            // TODO: По хорошему, нужна транзакция или откат предыдущих списаний
            break;
          }
        }
      }

      if (allRemoved) {
        // Уведомляем StateManager о покупке
        eventBus.emit("shop:item_purchased", { itemType: "skin", id: skinId });
        // Сразу экипируем купленный скин
        eventBus.emit("shop:skin_equip", { skinId });
        eventBus.emit("ui:notification_show", {
          type: "success",
          message: `Скин "${skinConfig.name}" куплен и надет!`,
        });
      } else {
        eventBus.emit("ui:notification_show", {
          type: "error",
          message: "Ошибка покупки скина!",
        });
        // Здесь нужно вернуть списанные средства, если логика отката реализована
      }
    }
  }

  // --- Открытие Лутбокса ---
  openLootbox(lootboxType) {
    const lootboxConfig = config.lootboxes[lootboxType];
    if (!lootboxConfig) return;

    const state = eventBus.emitSync("state:get");
    if (!state) return;

    const currency = lootboxConfig.currency;
    const cost = lootboxConfig.cost;

    // Проверяем и списываем валюту
    const success = eventBus.emitSync("currency:remove", {
      type: currency,
      amount: cost,
    });

    if (!success) {
      eventBus.emit("ui:notification_show", {
        type: "error",
        message: "Недостаточно монет!",
      });
      return;
    }

    // Определяем награду
    const reward = this.determineLootboxReward(lootboxConfig.rewards, state);

    // Обрабатываем дубликат скина ДО отправки события награды
    if (reward.type === "skin" && state.shop.skins.owned[reward.itemId]) {
      console.log(`Duplicate skin ${reward.itemId} from lootbox.`);
      const skinConfig = config.skins[reward.itemId];
      const coinReward = Math.max(
        Math.floor(skinConfig.cost * config.game.duplicateSkinCoinMultiplier),
        config.game.minCoinsForDuplicateSkin
      );
      // Модифицируем объект reward
      reward.wasDuplicate = true;
      reward.originalItemId = reward.itemId; // Сохраняем ID для UI
      reward.type = "coin";
      reward.amount = coinReward;
      console.log(`Converted to ${coinReward} coins.`);
    }

    // Отправляем событие с финальной наградой (StateManager ее применит)
    eventBus.emit("lootbox:reward", reward);

    // Показываем модальное окно с наградой
    eventBus.emit("ui:show_lootbox_reward", { lootboxType, reward });
  }

  // Логика определения награды из лутбокса
  determineLootboxReward(possibleRewards, currentState) {
    const rand = Math.random();
    let cumulativeChance = 0;

    for (const rewardInfo of possibleRewards) {
      cumulativeChance += rewardInfo.chance;
      if (rand < cumulativeChance) {
        let reward = { type: rewardInfo.type };
        if (
          reward.type === "coin" ||
          reward.type === "gem" ||
          reward.type === "ore"
        ) {
          reward.amount =
            Math.floor(Math.random() * (rewardInfo.max - rewardInfo.min + 1)) +
            rewardInfo.min;
        } else if (reward.type === "helper" || reward.type === "skin") {
          reward.rarity = rewardInfo.rarity;
          // Выбираем КОНКРЕТНЫЙ предмет этой редкости
          reward.itemId = this.selectRandomItem(
            reward.type,
            reward.rarity,
            currentState,
            reward.type === "skin"
          ); // Передаем флаг onlyUnowned для скинов

          if (!reward.itemId) {
            // Если подходящий предмет не найден
            console.warn(
              `No available ${reward.type} of rarity ${reward.rarity} found. Giving fallback coins.`
            );
            return { type: "coin", amount: config.game.fallbackLootboxCoins };
          }
        }
        return reward;
      }
    }
    // Fallback, если шансы не сошлись (сумма < 1)
    console.warn("Lootbox reward calculation failed. Falling back to coins.");
    return { type: "coin", amount: config.game.fallbackLootboxCoins };
  }

  // Выбор случайного предмета нужного типа и редкости
  selectRandomItem(itemType, rarity, currentState, onlyUnowned = false) {
    let possibleItems = [];
    const itemConfigs = config[itemType + "s"]; // config.helpers или config.skins

    for (const id in itemConfigs) {
      const itemConfig = itemConfigs[id];
      if (itemConfig.rarity === rarity) {
        if (itemType === "skin" && onlyUnowned) {
          // Проверяем, есть ли уже такой скин во владении
          if (!currentState.shop.skins.owned[id]) {
            possibleItems.push(id);
          }
        } else if (itemType === "helper") {
          // Для хелперов не важна уникальность, всегда добавляем
          possibleItems.push(id);
        } else if (itemType === "skin" && !onlyUnowned) {
          possibleItems.push(id); // Если можно дубликат
        }
      }
    }

    if (possibleItems.length > 0) {
      const randomIndex = Math.floor(Math.random() * possibleItems.length);
      return possibleItems[randomIndex];
    }
    return null; // Нет подходящих предметов
  }
}

// Экспортируем единственный экземпляр
export const shopManager = new ShopManager();

// js/stateManager.js
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";
import { getCurrentCost } from "./utils.js"; // Нужен для расчета стоимости перед списанием

class StateManager {
  constructor() {
    this.state = this.getInitialState();
    this.isInitialized = false; // Флаг для отложенного первого state:updated
    this.setupEventHandlers();
    console.log("StateManager initialized");
  }

  deepMerge(target, source) {
    const output = { ...target };
    if (this.isObject(target) && this.isObject(source)) {
      Object.keys(source).forEach((key) => {
        if (this.isObject(source[key])) {
          if (!(key in target)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = this.deepMerge(target[key], source[key]);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      });
    }
    return output;
  }

  isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }

  updateState(partialState) {
    let stateChanged = false;
    const newState = this.deepMerge(this.state, partialState); // Используем deepMerge

    // Проверяем, изменилось ли состояние (можно сделать более детальную проверку)
    if (JSON.stringify(this.state) !== JSON.stringify(newState)) {
      stateChanged = true;
      this.state = newState; // Присваиваем новое, смерженное состояние
    }

    if (stateChanged) {
      this.recalculateDerivedStats();
      if (this.isInitialized) {
        eventBus.emit("state:updated", this.state);
        eventBus.emit("state:forAchievements", this.state);
      }
    }
  }

  getInitialState() {
    const initialState = {
      currencies: { coin: 0, gem: 0, ore: 0 },
      totals: { coins: 0, gems: 0, ore: 0, taps: 0 }, // Общие накопленные значения
      stats: {
        // Статистика для достижений и прочего
        criticalHits: 0,
        energySpent: 0,
      },
      player: {
        level: 0,
        progress: 0,
        progressToNextLevel: config.game.baseProgressToNextLevel,
        baseTapValueFromLevel: 0, // Добавка к базовому тапу от уровня
      },
      energy: {
        current: config.game.maxEnergy, // Начнем с полной
        max: config.game.maxEnergy,
        regenRate: config.game.energyRegenRate,
      },
      shop: {
        // Состояние предметов магазина
        helpers: {}, // { dolphin: { owned: 1 }, orca: { owned: 0 }, ... }
        upgrades: {}, // { powerTap: { owned: 2 }, criticalChance: { owned: 0 }, ... }
        skins: {
          // Состояние скинов
          current: "basic",
          unlocked: ["basic"],
          owned: { basic: true }, // { basic: true, gold: false, ... }
        },
      },
      boost: {
        active: false,
        endTime: 0,
      },
      // Производные значения (рассчитываются)
      derived: {
        passiveIncomePerSec: 0,
        currentTapValue: config.game.baseTapValue,
        criticalChance: config.game.criticalChance,
        oreChance: config.game.oreChance,
      },
      achievements: {}, // { firstTap: { unlocked: false, progress: 50 }, ... }
    };
    // Инициализация состояний магазина из конфига
    Object.keys(config.helpers).forEach((id) => {
      initialState.shop.helpers[id] = { owned: 0 };
    });
    Object.keys(config.upgrades).forEach((id) => {
      initialState.shop.upgrades[id] = { owned: 0 };
    });
    Object.keys(config.skins).forEach((id) => {
      initialState.shop.skins.owned[id] = id === "basic"; // Только базовый скин владеем
    });
    Object.keys(config.achievements).forEach((id) => {
      initialState.achievements[id] = { unlocked: false, progress: 0 };
    });
    return initialState;
  }

  getState() {
    return this.state;
  }

  // Основной метод обновления состояния
  updateState(partialState) {
    let stateChanged = false;
    for (const key in partialState) {
      if (
        JSON.stringify(this.state[key]) !== JSON.stringify(partialState[key])
      ) {
        // Обновляем только если есть изменения (простая проверка)
        this.state[key] = { ...this.state[key], ...partialState[key] }; // Мержим объект состояния
        stateChanged = true;
      }
    }

    if (stateChanged) {
      this.recalculateDerivedStats(); // Пересчитываем производные значения
      // Отправляем событие только после полной инициализации
      if (this.isInitialized) {
        eventBus.emit("state:updated", this.state);
        eventBus.emit("state:forAchievements", this.state); // Отдельное событие для достижений, если нужно
      }
    }
  }

  // Загрузка сохраненного состояния
  loadState(loadedState) {
    if (!loadedState) {
      console.log("No saved state found, using initial state.");
      this.state = this.getInitialState(); // Убедимся, что используем свежее начальное состояние
    } else {
      console.log("Loading saved state...");
      // Аккуратно объединяем сохраненное состояние с начальным,
      // чтобы новые поля из config не потерялись
      const initialState = this.getInitialState();
      this.state = this.mergeStates(initialState, loadedState);
      console.log("State loaded:", this.state);
    }
    this.recalculateDerivedStats(); // Пересчитать все после загрузки
    this.isInitialized = true; // Теперь можно отправлять state:updated
    eventBus.emit("state:loaded", this.state); // Событие о завершении загрузки
    eventBus.emit("state:updated", this.state); // Первое обновление UI
  }

  // Рекурсивное объединение состояний (для вложенных объектов)
  mergeStates(target, source) {
    const output = { ...target };
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        const targetValue = target[key];
        const sourceValue = source[key];
        if (
          typeof sourceValue === "object" &&
          sourceValue !== null &&
          !Array.isArray(sourceValue) &&
          typeof targetValue === "object" &&
          targetValue !== null &&
          !Array.isArray(targetValue)
        ) {
          output[key] = this.mergeStates(targetValue, sourceValue);
        } else {
          // Просто перезаписываем, если не объект или если в target нет такого ключа/типа
          output[key] = sourceValue;
        }
      }
    }
    // Убедимся, что все ключи из target (initialState) присутствуют
    for (const key in target) {
      if (!Object.prototype.hasOwnProperty.call(output, key)) {
        output[key] = target[key];
      }
    }
    return output;
  }

  // Пересчет производных значений
  recalculateDerivedStats() {
    const state = this.state;
    const shopState = state.shop;
    const playerState = state.player;

    // 1. Пассивный доход
    let income = 0;
    for (const id in shopState.helpers) {
      income += shopState.helpers[id].owned * config.helpers[id].income;
    }
    // 2. Множитель дохода
    const incomeMultiplierUpgrade = config.upgrades.incomeMultiplier;
    const incomeMultiplierLevel = shopState.upgrades.incomeMultiplier.owned;
    const incomeMultiplier =
      incomeMultiplierLevel > 0
        ? Math.pow(incomeMultiplierUpgrade.effect, incomeMultiplierLevel)
        : 1;
    const finalIncome = Math.floor(income * incomeMultiplier);

    // 3. Шанс крита
    const critChanceUpgrade = config.upgrades.criticalChance;
    const critChanceLevel = shopState.upgrades.criticalChance.owned;
    const finalCritChance =
      config.game.criticalChance + critChanceLevel * critChanceUpgrade.effect;

    // 4. Шанс руды
    const oreChanceUpgrade = config.upgrades.oreChance;
    const oreChanceLevel = shopState.upgrades.oreChance.owned;
    const finalOreChance =
      config.game.oreChance + oreChanceLevel * oreChanceUpgrade.effect;

    // 5. Базовый тап (уровень + апгрейд)
    const powerTapUpgrade = config.upgrades.powerTap;
    const powerTapLevel = shopState.upgrades.powerTap.owned;
    let baseTap =
      config.game.baseTapValue +
      playerState.baseTapValueFromLevel + // Добавка от уровня
      powerTapLevel * powerTapUpgrade.effect;

    // 6. Множитель скина
    const currentSkinId = shopState.skins.current;
    const skinMultiplier = config.skins[currentSkinId]?.multiplier || 1;

    // 7. Итоговый тап (база * скин) - без крита и буста
    const finalTapValue = Math.floor(baseTap * skinMultiplier);

    // 8. Макс энергия и реген
    const maxEnergyUpgrade = config.upgrades.energyMax;
    const maxEnergyLevel = shopState.upgrades.energyMax.owned;
    const finalMaxEnergy =
      config.game.maxEnergy + maxEnergyLevel * maxEnergyUpgrade.effect;

    const energyRegenUpgrade = config.upgrades.energyRegen;
    const energyRegenLevel = shopState.upgrades.energyRegen.owned;
    const finalEnergyRegen =
      config.game.energyRegenRate +
      energyRegenLevel * energyRegenUpgrade.effect;

    // Обновляем состояние derived и energy
    state.derived = {
      passiveIncomePerSec: finalIncome,
      currentTapValue: finalTapValue, // Это базовый тап с учетом скина/апгрейдов
      criticalChance: finalCritChance,
      oreChance: finalOreChance,
    };
    state.energy.max = finalMaxEnergy;
    state.energy.regenRate = finalEnergyRegen;

    // Корректируем текущую энергию, если макс. изменилась
    if (state.energy.current > state.energy.max) {
      state.energy.current = state.energy.max;
    }
  }

  setupEventHandlers() {
    // --- Валюты ---
    eventBus.on("currency:add", ({ type, amount }) => {
      if (!this.state.currencies.hasOwnProperty(type)) return;
      amount = Math.max(0, amount); // Не добавлять отрицательные
      const current = this.state.currencies[type];
      const currentTotal = this.state.totals[type + "s"] || 0; // coins, gems, ores
      this.updateState({
        currencies: { [type]: current + amount },
        totals: { [type + "s"]: currentTotal + amount },
      });
    });

    // Синхронный обработчик для проверки и списания
    eventBus.on("currency:remove", ({ type, amount }) => {
      if (!this.state.currencies.hasOwnProperty(type) || amount <= 0)
        return false;
      const current = this.state.currencies[type];
      if (current >= amount) {
        this.updateState({ currencies: { [type]: current - amount } });
        return true; // Успех
      }
      return false; // Недостаточно средств
    });

    // --- Энергия ---
    eventBus.on("energy:add", ({ amount }) => {
      if (amount <= 0) return;
      const current = this.state.energy.current;
      const max = this.state.energy.max;
      const newEnergy = Math.min(max, current + amount);
      if (newEnergy !== current) {
        this.updateState({ energy: { current: newEnergy } });
      }
    });

    eventBus.on("energy:remove", ({ amount }) => {
      if (amount <= 0) return;
      const current = this.state.energy.current;
      const newEnergy = Math.max(0, current - amount);
      const spentAmount = current - newEnergy; // Сколько реально потрачено
      if (newEnergy !== current) {
        this.updateState({
          energy: { current: newEnergy },
          stats: {
            energySpent: (this.state.stats.energySpent || 0) + spentAmount,
          }, // Статистика для ачивки
        });
      }
    });

    // --- Покупка/Улучшение Предметов ---
    eventBus.on("shop:item_purchased", ({ itemType, id }) => {
      let updates = {};
      if (itemType === "helper" && this.state.shop.helpers[id]) {
        updates = {
          shop: {
            helpers: { [id]: { owned: this.state.shop.helpers[id].owned + 1 } },
          },
        };
      } else if (itemType === "upgrade" && this.state.shop.upgrades[id]) {
        updates = {
          shop: {
            upgrades: {
              [id]: { owned: this.state.shop.upgrades[id].owned + 1 },
            },
          },
        };
      } else if (
        itemType === "skin" &&
        this.state.shop.skins.owned.hasOwnProperty(id)
      ) {
        const newUnlocked = [...this.state.shop.skins.unlocked];
        if (!newUnlocked.includes(id)) {
          newUnlocked.push(id);
        }
        updates = {
          shop: { skins: { owned: { [id]: true }, unlocked: newUnlocked } },
        };
        // Сразу НЕ надеваем скин, если он не из лутбокса
        // Если нужно надевать, добавить: current: id
      }
      if (Object.keys(updates).length > 0) {
        this.updateState(updates); // Это вызовет recalculateDerivedStats
      }
    });

    // --- Смена скина ---
    eventBus.on("shop:skin_equip", ({ skinId }) => {
      if (this.state.shop.skins.owned[skinId]) {
        this.updateState({ shop: { skins: { current: skinId } } });
      }
    });

    // --- Открытие лутбокса (применение награды) ---
    eventBus.on("lootbox:reward", (reward) => {
      switch (reward.type) {
        case "coin":
        case "gem":
        case "ore":
          eventBus.emit("currency:add", {
            type: reward.type,
            amount: reward.amount,
          });
          break;
        case "helper":
          // Увеличиваем owned хелпера
          if (this.state.shop.helpers[reward.itemId]) {
            this.updateState({
              shop: {
                helpers: {
                  [reward.itemId]: {
                    owned: this.state.shop.helpers[reward.itemId].owned + 1,
                  },
                },
              },
            });
          }
          break;
        case "skin":
          // Отмечаем скин как owned и добавляем в unlocked
          if (this.state.shop.skins.owned.hasOwnProperty(reward.itemId)) {
            const newUnlocked = [...this.state.shop.skins.unlocked];
            if (!newUnlocked.includes(reward.itemId)) {
              newUnlocked.push(reward.itemId);
            }
            this.updateState({
              shop: {
                skins: {
                  owned: { [reward.itemId]: true },
                  unlocked: newUnlocked,
                },
              },
            });
          }
          break;
      }
      // Сохранение будет вызвано SaveManager'ом позже
    });

    // --- Игровые действия ---
    eventBus.on("game:tap_stats_update", ({ isCritical }) => {
      const updates = {
        totals: { taps: this.state.totals.taps + 1 },
      };
      if (isCritical) {
        updates.stats = {
          criticalHits: (this.state.stats.criticalHits || 0) + 1,
        };
      }
      this.updateState(updates);
    });

    // ИЗМЕНИ обработчик 'game:level_up'
    eventBus.on(
      "game:level_up",
      ({ newLevel, newProgress, newProgressToNextLevel }) => {
        let baseTapIncrease = 0;
        // Увеличение базового тапа от уровня
        if (
          newLevel > this.state.player.level &&
          newLevel % config.game.levelUpBaseTapIncreaseInterval === 0
        ) {
          baseTapIncrease = config.game.levelUpBaseTapIncreaseAmount;
        }
        this.updateState({
          player: {
            level: newLevel,
            progress: newProgress, // Устанавливаем правильный остаток прогресса
            progressToNextLevel: newProgressToNextLevel,
            baseTapValueFromLevel:
              this.state.player.baseTapValueFromLevel + baseTapIncrease,
          },
        });
        // Пересчитываем статы после изменения baseTapValueFromLevel
        this.recalculateDerivedStats();
        // Эмитируем state:updated т.к. recalculateDerivedStats не делает этого сам
        eventBus.emit("state:updated", this.state);
      }
    );

    // НОВЫЙ обработчик для простого обновления прогресса
    eventBus.on("game:progress_update", ({ newProgress }) => {
      // Проверяем, что уровень не должен был измениться (на всякий случай)
      if (newProgress < this.state.player.progressToNextLevel) {
        this.updateState({ player: { progress: newProgress } });
      } else {
        console.warn(
          "Progress update called when level up should have occurred!"
        );
        // Можно вызвать перерасчет левелапа здесь как fallback
      }
    });

    eventBus.on("game:boost_activated", () => {
      this.updateState({
        boost: {
          active: true,
          endTime: Date.now() + config.game.boostDuration,
        },
      });
    });

    eventBus.on("game:boost_deactivated", () => {
      this.updateState({ boost: { active: false, endTime: 0 } });
    });

    // --- Загрузка ---
    // Нужен для получения состояния при сохранении
    eventBus.on("state:get", () => this.getState());
    // Нужен для загрузки
    eventBus.on("state:load", (loadedData) => this.loadState(loadedData));
    // Нужен для инициализации/ресета
    eventBus.on("game:new", () => this.loadState(null));
  }
}

// Экспортируем единственный экземпляр
export const stateManager = new StateManager();

// js/uiManager.js
import { eventBus } from "./eventBus.js";
import { config } from "./config.js";
import { formatNumber, getCurrentCost, createElement } from "./utils.js";

class UIManager {
  constructor() {
    this.elements = this.cacheElements();
    this.setupEventListeners();
    this.renderStaticElements(); // Рендер того, что не меняется динамически
    console.log("UIManager initialized");
  }

  cacheElements() {
    return {
      // Валюты и энергия
      coinCount: document.getElementById("coin-count"),
      gemCount: document.getElementById("gem-count"),
      oreCount: document.getElementById("ore-count"),
      energyCount: document.getElementById("energy-count"),
      energyBar: document.getElementById("energy-bar"),
      // Игрок
      playerInfo: document.querySelector(".player-info"), // Контейнер для аватара и имени
      userName: document.getElementById("user-name"),
      userAvatar: document.getElementById("user-avatar"),
      playerLevel: document.querySelector(".player-level"),
      progressFill: document.querySelector(".progress-fill"),
      // Доход и тап
      income: document.querySelector(".income"),
      tapValueDisplay: document.getElementById("tap-value-display"), // Элемент для показа силы тапа (если нужно)
      // Кнопки действий
      shark: document.querySelector(".shark"),
      boostButton: document.getElementById("boost-button"),
      // Магазин
      shopTabsContainer: document.querySelector(".shop-tabs"),
      shopTabs: document.querySelectorAll(".shop-tab"), // Для переключения active
      shopContent: {
        // Контейнеры для рендера
        helpers: document.getElementById("helpers-tab"),
        upgrades: document.getElementById("upgrades-tab"),
        skins: document.getElementById("skins-tab"),
        lootboxes: document.getElementById("lootboxes-tab"),
      },
      // Модалки и уведомления
      lootboxModal: document.getElementById("lootbox-modal"),
      lootboxTitle: document.getElementById("lootbox-title"),
      lootboxReward: document.getElementById("lootbox-reward"),
      closeLootboxBtn: document.getElementById("close-lootbox"),
      levelUpNotification: document.getElementById("level-up-notification"),
      achievementNotification: document.getElementById(
        "achievement-notification"
      ), // Уведомление о достижении
      notificationArea: document.getElementById("notification-area"), // Область для общих уведомлений
    };
  }

  // Рендер элементов, которые не требуют постоянного обновления state
  renderStaticElements() {
    this.setupShopTabs();
    this.setupLootboxModal();
    // Можно отрендерить базовую структуру магазина один раз,
    // а потом только обновлять цены/уровни/кнопки
  }

  updateUI(state) {
    if (!state || !this.elements) return; // Проверка

    // Валюты
    if (this.elements.coinCount)
      this.elements.coinCount.textContent = formatNumber(state.currencies.coin);
    if (this.elements.gemCount)
      this.elements.gemCount.textContent = formatNumber(state.currencies.gem);
    if (this.elements.oreCount)
      this.elements.oreCount.textContent = formatNumber(state.currencies.ore);

    // Энергия
    if (this.elements.energyCount)
      this.elements.energyCount.textContent = state.energy.current;
    if (this.elements.energyBar)
      this.elements.energyBar.style.width = `${
        (state.energy.current / state.energy.max) * 100
      }%`;

    // Уровень и прогресс
    if (this.elements.playerLevel)
      this.elements.playerLevel.textContent = `Ур. ${state.player.level}`;
    if (this.elements.progressFill && state.player.progressToNextLevel > 0) {
      const progressPercentage =
        (state.player.progress / state.player.progressToNextLevel) * 100;
      this.elements.progressFill.style.width = `${progressPercentage}%`;
    } else if (this.elements.progressFill) {
      this.elements.progressFill.style.width = `0%`;
    }

    // Пассивный доход
    if (this.elements.income)
      this.elements.income.textContent = `+${formatNumber(
        state.derived.passiveIncomePerSec
      )}/сек`;

    // Сила тапа (если нужно отображать)
    if (this.elements.tapValueDisplay)
      this.elements.tapValueDisplay.textContent = `Тап: ${formatNumber(
        state.derived.currentTapValue
      )}`;

    // Кнопка буста
    if (this.elements.boostButton) {
      this.elements.boostButton.disabled = state.boost.active;
      this.elements.boostButton.innerHTML = state.boost.active
        ? '<i class="fas fa-rocket"></i> Буст Активен!'
        : '<i class="fas fa-rocket"></i> Буст';
    }

    // Обновление магазина (перерисовка нужной вкладки)
    this.renderShop(state); // Передаем текущее состояние
  }

  updateUserInfo(name, photoUrl) {
    if (this.elements.userName)
      this.elements.userName.textContent = name || "Игрок";
    if (this.elements.userAvatar)
      this.elements.userAvatar.src =
        photoUrl || "https://img.icons8.com/ios-filled/50/user-male-circle.png";
  }

  showLevelUpNotification(level) {
    const notification = this.elements.levelUpNotification;
    if (!notification) return;
    notification.querySelector("p").textContent = `Достигнут Уровень ${level}!`; // Пример
    notification.classList.add("show");
    // Дополнительные эффекты (свечение)
    if (this.elements.shark) {
      const glow = createElement("div", ["evolution-glow"]);
      this.elements.shark.parentNode.appendChild(glow); // Добавляем в wrapper
      setTimeout(() => glow.remove(), 2000);
    }
    setTimeout(() => notification.classList.remove("show"), 2000);
  }

  showAchievementNotification(achievementConfig) {
    const notification = this.elements.achievementNotification;
    if (!notification) return;
    notification.querySelector("h4").textContent = achievementConfig.name;
    notification.querySelector("p").textContent = achievementConfig.description;
    notification.classList.add("show");
    setTimeout(() => notification.classList.remove("show"), 3000);
  }

  showNotification({ type = "info", message = "...", duration = 3000 }) {
    if (!this.elements.notificationArea || !message) return;
    const notification = createElement(
      "div",
      [`notification`, `notification-${type}`],
      message
    );
    this.elements.notificationArea.appendChild(notification);
    setTimeout(() => {
      notification.classList.add("hide");
      setTimeout(() => notification.remove(), 500); // Удаляем после анимации
    }, duration);
  }

  // --- Управление Магазином ---

  setupShopTabs() {
    if (!this.elements.shopTabsContainer) return;
    this.elements.shopTabsContainer.addEventListener("click", (event) => {
      const tab = event.target.closest(".shop-tab");
      if (tab && tab.dataset.tab) {
        this.changeShopTab(tab.dataset.tab);
      }
    });
    // Активируем первую вкладку
    const firstTab = this.elements.shopTabsContainer.querySelector(".shop-tab");
    if (firstTab) {
      this.changeShopTab(firstTab.dataset.tab);
    }
  }

  changeShopTab(tabName) {
    this.elements.shopTabs.forEach((t) => t.classList.remove("active"));
    const activeTabElement = this.elements.shopTabsContainer.querySelector(
      `.shop-tab[data-tab="${tabName}"]`
    );
    if (activeTabElement) activeTabElement.classList.add("active");

    for (const name in this.elements.shopContent) {
      if (this.elements.shopContent[name]) {
        this.elements.shopContent[name].style.display =
          name === tabName ? "grid" : "none";
      }
    }
    // Перерисовываем содержимое активной вкладки при переключении
    const state = eventBus.emitSync("state:get");
    if (state) {
      this.renderShopTabContent(tabName, state);
    }
  }

  // Рендерит все вкладки магазина (вызывается при state:updated)
  renderShop(state) {
    const activeTab = this.getActiveShopTab();
    if (activeTab) {
      this.renderShopTabContent(activeTab, state);
    }
    // Можно оптимизировать и рендерить только если валюта или уровни предметов изменились
  }

  getActiveShopTab() {
    const activeTabElement =
      this.elements.shopTabsContainer?.querySelector(".shop-tab.active");
    return activeTabElement?.dataset?.tab || null;
  }

  // Рендерит содержимое конкретной вкладки
  renderShopTabContent(tabName, state) {
    const container = this.elements.shopContent[tabName];
    if (!container) return;

    container.innerHTML = ""; // Очищаем перед рендером

    switch (tabName) {
      case "helpers":
        this.renderHelpers(container, state);
        break;
      case "upgrades":
        this.renderUpgrades(container, state);
        break;
      case "skins":
        this.renderSkins(container, state);
        break;
      case "lootboxes":
        this.renderLootboxes(container, state);
        break;
    }
  }

  // Рендер Помощников
  renderHelpers(container, state) {
    const userCoins = state.currencies.coin;
    Object.entries(config.helpers).forEach(([id, itemConfig]) => {
      const itemState = state.shop.helpers[id];
      const currentCost = getCurrentCost(
        itemConfig.cost,
        itemState.owned,
        itemConfig.costIncrease
      );
      const canAfford = userCoins >= currentCost;

      const itemHTML = `
              <div class="shop-item-card ${
                itemConfig.rarity
              }" data-item-id="${id}" data-item-type="helper">
                 <div class="card-header">
                     <div class="card-icon"><i class="fas ${
                       itemConfig.icon
                     }"></i></div>
                     <div class="card-title">${itemConfig.name}</div>
                     <div class="rarity-badge ${itemConfig.rarity}">${
        itemConfig.rarity
      }</div>
                     <div class="card-price">
                        <span class="price-tag coins-price"><i class="fas fa-coins"></i> ${formatNumber(
                          currentCost
                        )}</span>
                     </div>
                 </div>
                 <div class="card-body">
                     <div class="card-description">+${
                       itemConfig.income
                     } Монет/сек. Уровень: ${itemState.owned}</div>
                     <button class="card-button" ${
                       !canAfford ? "disabled" : ""
                     }>
                        ${
                          itemState.owned > 0
                            ? `Куплено: ${itemState.owned}`
                            : "Купить"
                        }
                     </button>
                 </div>
              </div>`;
      container.insertAdjacentHTML("beforeend", itemHTML);
    });
  }

  // Рендер Улучшений
  renderUpgrades(container, state) {
    Object.entries(config.upgrades).forEach(([id, itemConfig]) => {
      const itemState = state.shop.upgrades[id];
      const currentCost = getCurrentCost(
        itemConfig.cost,
        itemState.owned,
        itemConfig.costIncrease
      );
      const currency = itemConfig.currency;
      const userCurrency = state.currencies[currency];
      const isMaxLevel =
        itemConfig.maxLevel && itemState.owned >= itemConfig.maxLevel;
      const canAfford = !isMaxLevel && userCurrency >= currentCost;

      let currencyIcon = "fa-coins";
      if (currency === "gem") currencyIcon = "fa-gem";
      if (currency === "ore") currencyIcon = "fa-cube";

      // Получаем описание эффекта
      let descriptionText = "";
      if (typeof itemConfig.description === "function") {
        descriptionText = itemConfig.description(
          itemState.owned,
          itemConfig.effect
        );
      } else {
        descriptionText = `Эффект: ${itemConfig.effect}`; // Фоллбэк
      }

      const itemHTML = `
              <div class="shop-item-card ${
                itemConfig.rarity
              }" data-item-id="${id}" data-item-type="upgrade">
                  <div class="card-header">
                      <div class="card-icon"><i class="fas ${
                        itemConfig.icon
                      }"></i></div>
                      <div class="card-title">${itemConfig.name}</div>
                      <div class="rarity-badge ${itemConfig.rarity}">${
        itemConfig.rarity
      }</div>
                      <div class="card-price">
                          <span class="price-tag ${currency}-price"><i class="fas ${currencyIcon}"></i> ${formatNumber(
        currentCost
      )}</span>
                      </div>
                  </div>
                  <div class="card-body">
                      <div class="card-description">${descriptionText} Уровень: ${
        itemState.owned
      }/${itemConfig.maxLevel || "∞"}</div>
                      <button class="card-button ${
                        isMaxLevel ? "maxed" : ""
                      }" ${isMaxLevel || !canAfford ? "disabled" : ""}>
                          ${isMaxLevel ? "Макс" : "Улучшить"}
                      </button>
                  </div>
              </div>`;
      container.insertAdjacentHTML("beforeend", itemHTML);
    });
  }

  // Рендер Скинов
  renderSkins(container, state) {
    const currentSkinId = state.shop.skins.current;
    Object.entries(config.skins).forEach(([id, itemConfig]) => {
      const isOwned = state.shop.skins.owned[id];
      const isEquipped = currentSkinId === id;

      let canAfford = false;
      if (!isOwned) {
        canAfford =
          state.currencies.coin >= itemConfig.cost &&
          state.currencies.gem >= itemConfig.costGems &&
          state.currencies.ore >= itemConfig.costOre;
      }

      let priceHTML = "";
      if (
        !isOwned &&
        (itemConfig.cost > 0 ||
          itemConfig.costGems > 0 ||
          itemConfig.costOre > 0)
      ) {
        if (itemConfig.cost > 0)
          priceHTML += `<span class="price-tag coins-price"><i class="fas fa-coins"></i> ${formatNumber(
            itemConfig.cost
          )}</span>`;
        if (itemConfig.costGems > 0)
          priceHTML += `<span class="price-tag gems-price"><i class="fas fa-gem"></i> ${formatNumber(
            itemConfig.costGems
          )}</span>`;
        if (itemConfig.costOre > 0)
          priceHTML += `<span class="price-tag ore-price"><i class="fas fa-cube"></i> ${formatNumber(
            itemConfig.costOre
          )}</span>`;
      } else if (isOwned) {
        // Можно ничего не показывать или "Куплено"
      } else {
        priceHTML = '<span class="price-tag free-tag">Бесплатно</span>';
      }

      let descriptionText = "";
      if (typeof itemConfig.description === "function") {
        descriptionText = itemConfig.description(itemConfig.multiplier);
      } else {
        descriptionText = itemConfig.description || "";
      }

      const itemHTML = `
            <div class="shop-item-card ${itemConfig.rarity} ${
        isEquipped ? "equipped-skin" : ""
      }" data-item-id="${id}" data-item-type="skin">
                 <div class="card-header">
                     <div class="card-icon skin-icon"><img src="${
                       itemConfig.iconSrc
                     }" alt="${itemConfig.name}"></div>
                     <div class="card-title">${itemConfig.name}</div>
                     <div class="rarity-badge ${itemConfig.rarity}">${
        itemConfig.rarity
      }</div>
                     <div class="card-price">${priceHTML}</div>
                 </div>
                 <div class="card-body">
                     <div class="card-description">${descriptionText}</div>
                     <button class="card-button ${
                       isEquipped ? "equipped" : isOwned ? "owned" : ""
                     }" ${
        isEquipped || (!isOwned && !canAfford) ? "disabled" : ""
      }>
                         ${isEquipped ? "Надет" : isOwned ? "Надеть" : "Купить"}
                     </button>
                 </div>
             </div>`;
      container.insertAdjacentHTML("beforeend", itemHTML);
    });
  }

  // Рендер Лутбоксов
  renderLootboxes(container, state) {
    Object.entries(config.lootboxes).forEach(([id, itemConfig]) => {
      const currency = itemConfig.currency;
      const cost = itemConfig.cost;
      const canAfford = state.currencies[currency] >= cost;

      let currencyIcon = "fa-coins";
      if (currency === "gem") currencyIcon = "fa-gem";
      if (currency === "ore") currencyIcon = "fa-cube";

      const itemHTML = `
             <div class="shop-item-card ${
               itemConfig.rarity
             }" data-item-id="${id}" data-item-type="lootbox">
                 <div class="card-header">
                      <div class="card-icon"><i class="fas ${
                        itemConfig.icon
                      }"></i></div>
                      <div class="card-title">${itemConfig.name}</div>
                      <div class="rarity-badge ${itemConfig.rarity}">${
        itemConfig.rarity
      }</div>
                      <div class="card-price">
                         <span class="price-tag ${currency}-price"><i class="fas ${currencyIcon}"></i> ${formatNumber(
        cost
      )}</span>
                      </div>
                 </div>
                 <div class="card-body">
                     <div class="card-description">${
                       itemConfig.description || ""
                     }</div>
                     <button class="card-button" ${
                       !canAfford ? "disabled" : ""
                     }>Открыть</button>
                 </div>
             </div>`;
      container.insertAdjacentHTML("beforeend", itemHTML);
    });
  }

  setupLootboxModal() {
    const modal = this.elements.lootboxModal;
    if (!modal) return;
    this.elements.closeLootboxBtn?.addEventListener(
      "click",
      () => (modal.style.display = "none")
    );
    window.addEventListener("click", (event) => {
      // Закрытие по клику вне окна
      if (event.target === modal) {
        modal.style.display = "none";
      }
    });
  }

  showLootboxRewardModal({ lootboxType, reward }) {
    const modal = this.elements.lootboxModal;
    if (!modal || !this.elements.lootboxTitle || !this.elements.lootboxReward)
      return;
    const lootboxConfig = config.lootboxes[lootboxType];
    if (!lootboxConfig) return;

    this.elements.lootboxTitle.textContent = lootboxConfig.name;
    // Используем форматированную награду
    this.elements.lootboxReward.textContent = `Вы получили: ${formatLootboxReward(
      reward
    )}`;
    modal.style.display = "flex";
  }

  // --- Обработчики Событий ---
  setupEventListeners() {
    // Обновление UI при изменении состояния
    eventBus.on("state:updated", (state) => this.updateUI(state));
    // Обновление UI после загрузки (первый рендер)
    eventBus.on("state:loaded", (state) => this.updateUI(state));

    // Обновление информации о пользователе
    eventBus.on("user:info_updated", ({ name, photoUrl }) =>
      this.updateUserInfo(name, photoUrl)
    );

    // Показ уведомлений
    eventBus.on("ui:notification_show", (data) => this.showNotification(data));
    eventBus.on("ui:show_level_up", ({ newLevel }) =>
      this.showLevelUpNotification(newLevel)
    );
    eventBus.on("ui:show_achievement", (achievementConfig) =>
      this.showAchievementNotification(achievementConfig)
    );
    eventBus.on("ui:show_lootbox_reward", (data) =>
      this.showLootboxRewardModal(data)
    );

    // --- Делегирование событий клика ---
    // Клик по акуле
    this.elements.shark?.addEventListener("click", (event) => {
      eventBus.emit("game:tap_request", { event }); // Отправляем запрос на тап
    });

    // Клик по кнопке буста
    this.elements.boostButton?.addEventListener("click", () => {
      eventBus.emit("game:boost_request");
    });

    // Клики внутри магазина (делегирование)
    Object.values(this.elements.shopContent).forEach((container) => {
      if (container) {
        container.addEventListener("click", (event) => {
          const button = event.target.closest("button.card-button");
          const card = event.target.closest(".shop-item-card");
          if (button && card && card.dataset.itemId && card.dataset.itemType) {
            const { itemId, itemType } = card.dataset;
            //console.log(`Shop click: type=${itemType}, id=${itemId}`);
            switch (itemType) {
              case "helper":
                eventBus.emit("shop:buy_helper_request", { helperId: itemId });
                break;
              case "upgrade":
                eventBus.emit("shop:buy_upgrade_request", {
                  upgradeId: itemId,
                });
                break;
              case "skin":
                eventBus.emit("shop:handle_skin_request", { skinId: itemId });
                break;
              case "lootbox":
                eventBus.emit("shop:open_lootbox_request", {
                  lootboxType: itemId,
                });
                break;
            }
          }
        });
      }
    });
  }
}

// Экспортируем единственный экземпляр
export const uiManager = new UIManager();

// js/utils.js
import { config } from "./config.js";

/**
 * Форматирует числа в k, m, b
 */
export function formatNumber(num) {
  if (num === undefined || num === null) return "0";
  if (num < 10000) return num.toString();
  if (num < 1000000) return (num / 1000).toFixed(1).replace(/\.0$/, "") + "k";
  if (num < 1000000000)
    return (num / 1000000).toFixed(1).replace(/\.0$/, "") + "m";
  return (num / 1000000000).toFixed(1).replace(/\.0$/, "") + "b";
}

/**
 * Рассчитывает текущую стоимость предмета с учетом количества и удорожания
 */
export function getCurrentCost(baseCost, owned, costIncrease) {
  return Math.floor(baseCost * Math.pow(costIncrease, owned));
}

/**
 * Форматирует текст награды из лутбокса для отображения
 */
export function formatLootboxReward(reward) {
  switch (reward.type) {
    case "coin":
      if (reward.wasDuplicate) {
        const originalSkinConfig = config.skins[reward.originalItemId];
        const skinName = originalSkinConfig
          ? originalSkinConfig.name
          : reward.originalItemId;
        return `${formatNumber(
          reward.amount
        )} монет (Дубликат скина: ${skinName})`;
      }
      return `${formatNumber(reward.amount)} монет`;
    case "gem":
      return `${formatNumber(reward.amount)} гемов`;
    case "ore":
      return `${formatNumber(reward.amount)} руды`;
    case "helper":
      const helperConfig = config.helpers[reward.itemId];
      return `Помощник: ${helperConfig ? helperConfig.name : reward.itemId}`;
    case "skin": // Сработает только если не дубликат
      const skinConfig = config.skins[reward.itemId];
      return `Новый скин: ${skinConfig ? skinConfig.name : reward.itemId}`;
    default:
      return `Неизвестная награда (${reward.type})`;
  }
}

/**
 * Создает HTML-элемент с классами и текстом
 */
export function createElement(tag, classNames = [], textContent = "") {
  const element = document.createElement(tag);
  if (classNames.length > 0) {
    element.classList.add(...classNames);
  }
  if (textContent) {
    element.textContent = textContent;
  }
  return element;
}
